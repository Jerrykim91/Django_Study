# Python web programming with Django
- setting은 고유 키가 있어서 덮어 쓰기 하지 말것 ! 
---

## 장고(Django) 특징

1. 구성요소들 간의 긴밀한 통합 <br/>
    - 장고는 각 요소가 긴밀하게 통합되어 있음  <br/>
    - 모든 부분이 통합적(integration)이며 동작이 빠르다. 그리고 재사용 가능하게 설계 <br/>

2. **객체관계의 매핑**     
    - 객체 관계의 매핑(Object-Relational Mapper, ORM))이란 ?     
        : 데이터 베이스 엔진과 데이터 모델을 연결시키는 다리와 같은 역활      
    - 직접적으로 SQL을 다루지 않아도 된다.       
    - 다양한 데이터 베이스를 지원, 유연한 데이터 베이스 시스템 변경         
    - 장고는 데이터베이스를 일관성 있게 추상화해서 단일한 API로 여러 데이터베이스를 사용         

3. 간단한 URL 주소 설계(우아한 URL 설계)      
    - 강력하고 유연한 URL 주소 디자인        
         - URL주소 형태를 직접 결정       
         - 직관적이고 쉽게 표현할 수 있음        
         - 정규표현식을 사용하여 복잡한 URL도 표현가능      

    - 파이썬 함수를 각 주소 형태와 직접 연결 => (1:1) <br/>
        - 개발이 편리하며 이해하기도 쉬움<br/>
        - 일반 사용자와 검생 엔진 각각에 알맞는 결과를 제공 <br/>

4. 자동으로 구성되는 관리자 화면 <br/>
    - 데이터베이스에 대한 관리기능을 위하여 프로젝트를 시작하는 시점에 기본기능으로 관리자 화면이 제공 <br/>
    - 장고는 실행하는 순간 미리 내장되어 있는 관리자 화면 제공 <br/>
    - 여러 어플리케이션의 데이터를 쉽게 관리, 재구성 <br/>

5. 풍부한 개발 환경<br/>
    - 테스트용 서버를 포함 => 아파치 등의 웹서버가 없어도 테스트 진행 가능 <br/>
    - 가벼운 웹 서버를 포함하고 있고 개발뿐아니라 테스트 용도로 사용가능 <br/>
    - 디버깅 모드를 사용할 경우 장고는 에러를 쉽게 파악하고 해결할 수 있게 상세한 에러 메세지를 보여줌        

6. 자체 템플릿 시스템 <br/>
    - 내부적으로 확장이 가능하고 디자인이 쉬운 강력한 템플릿 시스템을 가지고 있음 <br/>
        - 화면 디자인과 로직에 대한 코딩을 분리하며 독립적으로 개발이 진행이 가능 <br/>
        - 장고의 템플릿 시스템은 HTML같은 텍스트형 언어를 쉽게 다룰 수 있도록 개발되었음     
    - 간단하고 확장 할 수 있는 템플릿 텍스트처리엔진 (template and text filtering engine)

7. 캐시 시스템      
    - 성능 향상에 도움이 되는 캐싱 시스템 <br/>
    - 자주 이용되는 내용을 저장 => 재사용 => 성능을 높힘<br/>
    - 캐시용 페이지를 메모리, 데이터 베이스 내부, 파일 시스템중 아무 곳에나 저장 <br/>
    - 캐시 단위를 페이지에서부터 사이트 전체 또는 특정 뷰의 결과, 템플릿의 일부영역만 지정하여 저장 가능 <br/>

8. 소스변경사항 자동반영 <br/>
    - 실행파일 변경내역을 바로 반영 <br/>
    - 테스트용 웹이 실행중에 소스파일을 수정하더라도 다시시작할 필요없이 자동으로 새로운 파일이 반영 <br/>

9. 이외<br/>
    - 폼을 만들고 사용자 입력을 검사하는 유효성 검사 API<br/>
    - 확장할 수 있는 인증 시스템 <br/>
    - 다국어 지원 
    - RSS 피드를 만들어 주는 피드시스템(feed framework)<br/>
---

## 헷갈리는것 같아서 <br/>
- views는 동작을 생성하는 곳        
- ulrs는 모듈안에서 뷰에 선언된 동작을 경로화 시키는 곳<br/>   

- **Parameter Placeholder = %s**<br/> 
    - 이 %s 는 일반문자열 포맷팅에 사용하는 %s, %d등과는 다름<br/>
    - Parameter Placeholder에서는 문자열이건 숫자건 모두 %s를 사용<br/> 
    - 문자열이라도 인용부호를 사용 하지않음 
    - 그리고 컬럼값을 대치할때만 사용이 가능<br/>  
        => 그 말은 테이블이나 기타 문장에서는 Placeholder를 사용할 수 없음<br/> 

---

# 기본 구조

``` bash
    Django web project(여기서 web01을 생성)
    ㄴ Web01 => 이름을 변경하는것이 공통으로 통제하기 수월함
        ㄴ Web01
            - 프로젝트 설계를 위한 python 패키지들 이저장    
            ㄴ __init__.py 
                - 디렉토리를 패키지처럼 다루라고 알려주는 파일 
                => 이름이 중복되는것을 피하게 하는 모듈의 모음 
            ㄴ setting.py 
                - 프로젝트의 환경 및 구성을 저장
                - 환경 설정이 어떻게 동작하는지 확인
                - 데이터베이스, 사이트 언어 설정 
            ㄴ urls.py
                - 설정파일 
                    - 현재 Django project 의 URL 선언을 저장 => 사이트의 '목차'
                    - url주소와 장고의 기능을 연결 시켜주는 역활 
                    - 장고의 강력한 기능**
        ㄴ manage.py
            - 프로젝트를 관리하는 스크립트 admin.py와 코드를 공유 
            
```
### 생성
```py    
# Board 앱 생성(여러개 생성 가능)
    $ django-admin startapp board
# 의문사항 => 직접해보자 
    $ django-admin.py startapp member
    $ django-adminb startproject member
# Member 앱 생성
    $ django-admin startapp member 
# Django 서버 구동(http://127.0.0.1:8000/)
    $ python manage.py runserver 

# DB 연동=> SET IT UP**
    $ python manage.py migrate
```



---

### 구성

- 프로젝트 생성     
    - Istall Django Web     
        - Django 모듈 설치(없다면)    
    - Newproject 생성     
        - 확인 할 부분!! manage.py있는지 확인    
    - 잘 생성 되었으면 생성한 프로젝트 폴더로 이동      

- Web 요소 구성하기     
    - Board 앱 생성(여러개 생성 가능)    
    - Member 앱 생성     
    - Django 서버 구동(http://127.0.0.1:8000/)    
        - Page 열리는지 확인 => 확인 후  
    -> 열리면 회원가입 및 로그인 구현하기<br/> 

- 회원 관리 시스템 - 기능추가
    - Memebr      
        - 로그인       
        - 회원가입     
        - 회원정보수정     
        - 로그아웃

    - Board & Blog & 
        - 글쓰기
        - 글보기
        - 글수정
        - 글삭제

    - Poll


- INDEX 페이지 생성
    - URL주소와 장고의 기능을 연결 하기위해  web01\urls.py에서 urls를 지정
    - ```web01\urls.py```의 path()함수 안에 ```urls주소/```를 불러 올 url 정보 혹은 동작을 어디에서부터 가지고 올건지를 정의 => urls주소\urls.py    
        - ```include('urls주소\.urls') # 경로를 포함한다.  ```
        => member 폴더 안에 member\urls.py를 생성하고 경로를 직접적으로 지정         
        **중요 => import include를 까먹지 말것 !!**    

    - 동작확인을 하기전     
        - 예를들면 member app안에 urls를 작성!       
            - view로 이동 => 동작을 만든다(메소드 생성)  
            - HTML 파일을 생성        
                - 만약 템플릿 폴더가 없다면 먼저 생성하고 파일을 생성     

---

#### Django 에서는 기본적으로 CSRF 토큰을 이용해 CSRF공격을 방지
 > CSRF 공격이란?
- CSRF 공격(Cross Site Request Forgery)은 웹 어플리케이션 취약점 중 하나로, 인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격


---

### 구성에 따른 구조 파악

```bash
    Django web project 
        => 이름을 변경하는것이 공통으로 통제하기 수월함(처음은 메인 폴더이름이랑 동일)     
        ㄴ Web01(127.0.0.1:8000/board/index)
        
            
            ㄴ urls.py
                ㄴ 설정 파일 
                    - url주소와 장고의 기능을 연결 시켜주는 역활 
            ㄴ setting.py
                ㄴ 설정 파일 
                    - DB
                    - 사이트 언어
        ㄴ manage.py
        ㄴ Member
            ㄴ views.py (함수형 뷰)
            ㄴ urls.py  (함수형 뷰 호출 => member/views.py로부터)
            ㄴ models.py
        ㄴ Static (CSS)
            ㄴ CSS
        ㄴ Templates(HTML)
            ㄴ member
                ㄴ index.html
        ㄴ Board(app폴더)
            ㄴ views.py 
            ㄴ urls.py  
            ㄴ models.py  
        ㄴ Blog (구성은 보드랑 동일)
        ㄴ Poll (구성은 보드랑 동일)

    - 주석 일단 다 달고 전부 작업 한 후에 주석 제거합시다.
```
---

## 회원 관리 시스템 설계 

0. 전체적인 흐름은 먼저 뼈대를 먼저 생성하고 
1. 디지털 스토리보드 생성 
2. 그 시안을 기준으로 뼈대에 살입힌후 
3. 테스트 / 버그잡기 
4. 마지막에 웹 페이지 디자인에 들어가겠음 

### 회원가입 - 메소드 생성
- 구상하기
- 회원정보를 사용자로부터 받아 와야 해     
    => 어디서 받냐면        
    => 사용자입력 => DB가 저장 => 동작하는 방식(GET / POST)          

- 회원 가입     
    - 메소드 생성 -> 최적화      
    - Signup(2-회원가입) -> def sign_up(request): SQL 부분    

    ```SQL
            -- 테이블에 데이터를 삽입하는 코드  
            -- 컬럼위치에 매치된 데이터를 입력 
            -- INSERT INTO 테이블명(칼럼1,칼럼2,칼럼3,....) values(데이터1,데이터2,데이터3,......)
        INSERT INTO MEMBER( ID, PW, AGE, NAME, JOINDATE ) 
        VALUES(%s,%s,%s,%s, SYSDATE)
    ```

### 로그인 - 메소드 생성 

- GET, POST 방식          
    - GET방식 
        - 지정한 url의 정보를 가져오는 메소드      
    - POST방식 
        - 대표적인 기능, 리소스생성 => 블로그에 글을 등록하는 경우 => url 결정권이 서버 측에 있을 경우 post<br/>      

**로그인은 어떻게해야하나**  =>  LOGIN도  GET, POST 방식      
WHY? => 사용자로 부터 값을 입력 받아야 하니까 <br/>      

- 의문) 사용자 입력을 디비로 받고 저장하고 다시 사용자에게 값을 던질때      
    만약 post라는 형식의 동작이라면 그 동작을 변수에 담는데 왜 배열에 담는걸까?<br/>   
    => 짐작으로는 담은 순서대로 출력하기 위해서 인것 같은데<br/>     
    => 디비때문임<br/>     

- 로그인<br/>     

    1. 사용자가 로그인 정보 값을 던질때     
    2. 서버가 받고    
    3. 저장하고 (데이터 베이스에)     
    4. 그걸 다시 읽고      
    5. pass / no pass    

-  signin(3-로그인) -> def sign_in(request): SQL 부분<br/> 

```SQL
-- 직역 | 멤버라는 테이블로부터 아이디와 네임을 선택한다 
-- 근데 그게 전달 받은 ID,PW의 줄에 있는 네임과 아이디 
SELECT ID, NAME FROM MEMBER 
WHERE ID = %s AND PW = %s

```
- Cursor_ 커서 

    - ``` fetchall() ``` 메서드 
        - 모든 데이터를 한꺼번에 클라이언트로 가지고 올때 사용
    - ``` fetchone() ``` 메서드 
        - 한 번 호출에 하나의 row만을 가져올 때 사용
        - 여러번 호출을 하면 호출 할 때마다 한 row씩 데이터를 가지고 옴

- ** 로그인시에 아이디나 비밀번호를 한번치면 홈으로 바로 넘어가던 오류를 수정** 

---

### 사용자 수정

    사용자 수정은 어떤 동작을 하지 ? 
    -> 수정이지     
    -> 어떻게 ?     
        => DB에 저장된 정보를 불러와서 수정하는 거지    

    -> 어떤 방식으로 사용자를 수정하는건지 
        => 아이디/ 이름/ 나이만 수정 

    1. **사용자 정보를 받아야지 
        => 세션으로 => userid  
            => 의문) 왜 세션으로 사용자 정보를 받는거지 ?
    2. sql문을 작성 
        => 아이디 하나로 정보 불러온다


- 세션이란?     
    - **일정시간 동안 같은 사용자, 브라우저로부터 들어오는 일련의 요구**를 하나하나의 상태로 보고 **그 상태를 일정하게 유지**시키는 기술     
    - 사용자 정보를 **브라우저에** 저장하지 않고 **서버에서** 관리 

- 만료시점 
    - 서버에서 클라이언트를 구분하기 위해서 세션 아이디를 부여
        -> 웹브라우저가 서버에 접속해서 브라우저를 종료할때까지 인증 상태 유지

- 세션의 장단점 
    - 클라이언트의 정보를 서버에 저장하기때문에 쿠키보다 보안에 우수하다
    - 하지만 서버의 메모리를 많이 차지하여서 성능저하의 원인이 될 수 있음 

- 세션의 동작방식 
    - 클라이언트가 서버에 접속시 세션아이디를 발급 
        => 클라이언트는 세션 아이디에 쿠키를 사용해서 저장
        => 클라이언트가 서버에 다시 접속 시 이 쿠키를 이용해서 
        => 세션 아이디 값을 서버에 전달 

---

### 사용자 삭제 
- 의문 왜 사용자 삭제에 세션을 쓰는지 ...
    => 세션이 로그인 사용자를 계속 유저로 유지시켜주는건데 
    만약 세션이 없으면 회원이 아닌 거죠 ...? 

```py
def delete(request):
    # data => 회원정보
    if request.method == 'GET' or request.method =='POST':
        # 이 구조를 이해해야 ar 대신 뭐를 변수 명으로 넣을지 선정할수 있을 것 같음 
        # 일단은 ar은 배열의 약자
        ar = [ request.session['userid'] ]
        # 업데이트 문 
        sql = """
        DELETE FROM MEMBER WHERE ID=%s
        """
        cursor.execute(sql,ar)

        return render(request, '/member/logout')

```

### 사용자 리스트  - 관리자용 페이지 

- 사용자 정보 목록 
    - 해야하는거   
     1. 정보를 얻는다    
     2. 디비로 부터 => sql문 작성     
     3. html 출력  => fetchall() 받은 값을    
     4. 사전 형태의 값으로 html로 뿌린다.     
        => 어떻게 뿌릴건지 정하기  



---

## 번외 
### SQLite 설치
- 오라클 사용할거라 그냥 실습
- 설치는 아래 링크로 이동 
> 4번째_DB Browser for SQLite - .zip (no installer) for 64-bit Windows  
[주소로 이동](https://sqlitebrowser.org/dl/)