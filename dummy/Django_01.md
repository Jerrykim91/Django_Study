# Django ==  Chapter 01
---

# 장고(Django)_01
 - 가장 준비가 잘 되어있는 프레임워크
 - 제공하는 기능이 풍부함
 - 쉽고 빠르게 웹개발이 가능 
 - 사용자가 많음 


# 장고의 특징 

1. 구성요소들 간의 긴밀한 통합 <br/>
    - 장고는 각 요소가 긴밀하게 통합되어 있음  <br/>
    - 모든 부분이 통합적(integration)이며 동작이 빠르다. 그리고 재사용 가능하게 설계 <br/>

2. **객체관계의 매핑**     
    - 객체 관계의 매핑(Object-Relational Mapper, ORM))이란 ?     
        : 데이터 베이스 엔진과 데이터 모델을 연결시키는 다리와 같은 역활      
    - 직접적으로 SQL을 다루지 않아도 된다.       
    - 다양한 데이터 베이스를 지원, 유연한 데이터 베이스 시스템 변경         
    - 장고는 데이터베이스를 일관성 있게 추상화해서 단일한 API로 여러 데이터베이스를 사용         

3. 간단한 URL 주소 설계(우아한 URL 설계)      
    - 강력하고 유연한 URL 주소 디자인        
         - URL주소 형태를 직접 결정       
         - 직관적이고 쉽게 표현할 수 있음        
         - 정규표현식을 사용하여 복잡한 URL도 표현가능      

    - 파이썬 함수를 각 주소 형태와 직접 연결 => (1:1) <br/>
        - 개발이 편리하며 이해하기도 쉬움<br/>
        - 일반 사용자와 검생 엔진 각각에 알맞는 결과를 제공 <br/>

4. 자동으로 구성되는 관리자 화면 <br/>
    - 데이터베이스에 대한 관리기능을 위하여 프로젝트를 시작하는 시점에 기본기능으로 관리자 화면이 제공 <br/>
    - 장고는 실행하는 순간 미리 내장되어 있는 관리자 화면 제공 <br/>
    - 여러 어플리케이션의 데이터를 쉽게 관리, 재구성 <br/>

5. 풍부한 개발 환경<br/>
    - 테스트용 서버를 포함 => 아파치 등의 웹서버가 없어도 테스트 진행 가능 <br/>
    - 가벼운 웹 서버를 포함하고 있고 개발뿐아니라 테스트 용도로 사용가능 <br/>
    - 디버깅 모드를 사용할 경우 장고는 에러를 쉽게 파악하고 해결할 수 있게 상세한 에러 메세지를 보여줌        

6. 자체 템플릿 시스템 <br/>
    - 내부적으로 확장이 가능하고 디자인이 쉬운 강력한 템플릿 시스템을 가지고 있음 <br/>
        - 화면 디자인과 로직에 대한 코딩을 분리하며 독립적으로 개발이 진행이 가능 <br/>
        - 장고의 템플릿 시스템은 HTML같은 텍스트형 언어를 쉽게 다룰 수 있도록 개발되었음     
    - 간단하고 확장 할 수 있는 템플릿 텍스트처리엔진 (template and text filtering engine)

7. 캐시 시스템      
    - 성능 향상에 도움이 되는 캐싱 시스템 <br/>
    - 자주 이용되는 내용을 저장 => 재사용 => 성능을 높힘<br/>
    - 캐시용 페이지를 메모리, 데이터 베이스 내부, 파일 시스템중 아무 곳에나 저장 <br/>
    - 캐시 단위를 페이지에서부터 사이트 전체 또는 특정 뷰의 결과, 템플릿의 일부영역만 지정하여 저장 가능 <br/>

8. 소스변경사항 자동반영 <br/>
    - 실행파일 변경내역을 바로 반영 <br/>
    - 테스트용 웹이 실행중에 소스파일을 수정하더라도 다시시작할 필요없이 자동으로 새로운 파일이 반영 <br/>

9. 이외<br/>
    - 폼을 만들고 사용자 입력을 검사하는 유효성 검사 API<br/>
    - 확장할 수 있는 인증 시스템 <br/>
    - 다국어 지원 
    - RSS 피드를 만들어주는 피드 시스템(feed framework)<br/>



# 뷰(views), 모델(model) 그리고 템플릿(template)

 + 뷰(views) <br/>
    - 평범한 파이썬 함수 =>사용자 입력을 인수로 전달받아서 페이지를 반환<br/>
    - but! 작성한 내용을 브라우저에서 확인하기 전에 이 함수와 연결 할 URL을 정의<br/>
    - 새로운 환영 메시지 페이지를 만들기 위해서는 URL로 표현된 형식을 이용해서 파이썬 함수와 애플리케이션을 연결     <br/>
    - 뷰는 페이지를 호출하면 그 응답으로 페이지를 만들어주는 파이썬 함수<br/>  
    - 장고 애플리케이션을 프로젝트 아래에 생성 <br/>
        => 애플리케이션은 뷰와 데이터 모델(data model)의 묶음     <br/>

+ 모델(model) <br/>
    - 초기 데이터베이스 구조를 설계<br/>
    - 데이터베이스 구조설계<br/>

+ 템플릿(template) <br/>
    - 메인 페이지의 템플릿을 작성<br/>
    - 템플릿 위치 지정      
        => os.path.join(BASE_DIR) <br/>  


# URL 설계 개발할때 !
=> 고객의 요구사항이 정리되면 <br/>   
    - 디자인측면 => UI를설계  <br/>
    - 프로그램 로직 => URL을 설계   <br/>
        - URL 설계는 사용자에게 웹서버가 가지고 있는 기능을 명시해주는 단계      
=> 전체 프로그램로직을 생각하면서 <br/>
=> 차후에 로직이 변경되더라도 URL변경은 최소화 할수있도록 유연하게 설계해야함 <br/>      


**URL을 바라보는 측면**<br/>     
### URL 
- RPC (Remote procedure call) <br/>
        : 클라이언트가 네트워크상에서 원격에 있는 서버가 제공하는 API 함수를 호출하는 방식      
            -> URL의 경로를 API함수명으로, 쿼리 파라메터의 함수인자로 간주        
            => URL을 전송 = 웹서버 API함수를 호출 => 인식       
ㄴ REST (Representational State Transfer)         
        : 웹서버에 존재하는 요소들을 모두 리소스(시간이 지나면 상태변함 => 조작은 HTTP메소드)라고 정의      
            => URL을 통해 웹서버의 특정리소스를 표현한다는 개념        
- 우아한 URL          
    - 정규표현식을 추가적으로 사용가능함        
        => URL을 좀더 구체적으로 표현 가능          


# 웹 애플리케이션 서버
- 요청을 받아 처리하는 서버를 통칭 => '웹 서버' <br/>
- 세분화 <br/>
    - 웹서버(정적)       
        : 웹클라이언트의 요청을 받아서 요청을 처리
            => 그 결과를 클라이언트에게 응답( HTML, IMG, CSS... )      
    - 웹 애플리케이션(동적)      
        : 웹서버로부터 동적페이지 요청을 받아서 요청을 처리
            => 그 결과를 웹서버로 반환( 프로그램실행, DB )       
        
- **정적, 동적**    <br/>  
=> 사용자가 페이지를 요청하는 시점에 페이지의 내용이 유지되는가 변경되는가를 구분하는 용어 <br/>  
    - 정적인 페이지란 ?      
            - 누가, 언제 요구하더라도 항상 같은 내용을 표시하는 웹페이지     
                => 주로 자바스크립트, HTML, CSS 등등...       
    - 동적인 페이지란 ?       
            - 동일한 리소스의 요청이라도 누가, 언제 어떻게 요구했는지에 따라 각각 다른 내용이 반환되는 페이지를 말함      
                => 온라인쇼핑 사이트에서 사용자마다 다른카트 내용을 보여주는 페이지            

###  애플리케이션 서버방식 

<img src="https://github.com/Jerrykim91/Django_Study/blob/master/data/CGI%EB%B0%A9%EC%8B%9D%EC%9D%98%20%EC%9A%94%EC%B2%AD%EC%B2%98%EB%A6%AC.PNG?raw=true" width="700" height="200">      

=> CGI방식의 요청처리     

<img src="https://github.com/Jerrykim91/Django_Study/blob/master/data/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%84%9C%EB%B2%84%EB%B0%A9%EC%8B%9D%EC%9D%98%20%EC%9A%94%EC%B2%AD%EC%B2%98%EB%A6%AC.PNG?raw=true" width="700" height="200">      

=> APP 서버방식의 요청 처리     

<img src="https://github.com/Jerrykim91/Django_Study/blob/master/data/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%84%9C%EB%B2%84%EB%B0%A9%EC%8B%9D%EC%97%90%EC%84%9C%EC%9D%98%20%EC%84%9C%EB%B2%84%20%EA%B0%84%20%EA%B5%AC%EC%84%B1%EB%8F%84.PNG?raw=true" width="700" height="200">     

=> APP 서버방식에서의 서버간 구성도     

 - 웹서버와 웹어플리케이션이 분리     
    => 역활도 구분하여 사용      
 - 정적인 페이지를 처리하는 경우에 비해서 동적 페이지를 처리하는 경우가 메모리를 정-말 많이 소비       
    => 정적이 페이지처리에 특화된 웹서버는 정적인 페이지에서만 처리        
    => 웹어플리케이션 서버는 동적인 페이지만 처리하도록 역활분담을 하는것이 좋음      
    => 둘다 모두 처리하는것보다 훨-씬 더많은 요청을 처리할 수있음        

# 어플리케이션 개발 방식   
- 웹사이트를 설계할때       
    - 가장 먼저 해야할일 => 프로그램이 할일을 정당한 크기로 나누어서 모듈화 하는것       
    - 즉, 프로그램으로 코딩할 대상을 애플리케이션이라 명명      
- 장고에서는 애플리케이션들이 모여서 프로젝트를 개발하는 개념을 가지고 있음 
    - 전체 프로그램 => 프로젝트(project)      
    - 애플리케이션  => 모듈화된 단위프로그램     
    
# MVC  =>  MVC 패턴 기반 MVT 
- 웹개발 시 일반적으로 언급되는 MVC패턴 
    => 각 로직(뷰, 모델, 템플릿)을 구분해서 한 요소가 다른 요소들에게 영향을 주지 않도록 설계하는 방식  

- 장고는 MVC(model, view, controller)를 기반으로 한 프레임워크 
      - MVT 프레임워크라고 부르기도 함 => 용어만 다를뿐 개념은 동일    
- 컨트롤러(controller), 템플릿(template) => '뷰(views)' 라고 함      
    - 뷰(views) 
        - 실질적으로 프로그램 로직이 동작하여 데이터를 가져오고 적절하게 처리한 결과를 템플릿에 전달하는 역활을 수행      
        - 블로그에서 버튼을 눌렀을때 어떤함수를 호출하여 데이터를 어떻게 가공할건지 결정하는 역활
    - 모델(model)  
        - 데이터 베이스에 저장되는 데이터를 의미       
        - 블로그 내용을 데이터 베이스로 가지고 오거나 저장, 수정 
    - 템플릿(template) 
        - 사용자에게 보여지는 UI 부분   
        - 화면 출력을 위해 디자인과 테마를 적용해서 보여지는 페이지를 만들어주는 역활   

---
<img src="https://github.com/Jerrykim91/Django_Study/blob/master/data/%EC%9E%A5%EA%B3%A0%EC%9D%98%20mvt%ED%8C%A8%ED%84%B4.PNG?raw=true" width="700" height="300">          

=> 장고의 MVT 패턴   
---

+ 클라이언트로부터 요청을 받으면 URLconf를 이용하여 URL을 분석     
+ URL 분석 경과를 통해 해당 url에 대한 처리를 담당할 뷰를 결정    
+ 뷰는 자신읠 로직을 실행하면서, 만약 데이터 베이스 처리가 필요하면 모델을통해 처리하고  그결과를 반환 받음       
+ 뷰는 자신의 로직처리가 끝나면 템플릿을 사용하여 클라이언트에 전송할 HTML파일을 생성    
+ 뷰는 최종 결과로 HTML 파일을 클라이언트에게 보내 응답      


# Model - 데이터 베이스의 정의 
- 모델(Model) => 무조건 클래스로 생성 
    - 사용될 데이터에 대한 정의를 담고 있는 장고의 클래스     
    - ORM 기법을 사용 => 애플리캐이션에서 사용할 데이터베이스를 클래스로 매핑 => 코딩      
    - 하나의 모델 클래스는 하나의 테이블에 매핑 => 모델 클래스의 속성은 테이블의 컬럼에 매핑      
- ORM(Object Relational Mapping)    
    - 객체와 관계형데이터 베이스를 연결해주는 역활을 함     
    - 데이터베이스 대신 객체(클래스)를 사용해 데이터 처리     
    - 자동으로 적절한 SQL 구문이나 데이터베이스 API를 호출해서 처리     

- 장고는 테이블 및 컬럼을 자동으로 생성하기위해 필요한 많은 규칙을 가지고 있음 
     1. 테이블 명은 애플리캐이션 명과 모델명을 밑줄(_)로 연결 
     1. 모두 소문자로 표시 
     1. PK는 클래스에서 정의하지 않아도 장고가 자동으로 부여 => 개발자가 지정도 가능 
     1. 등등 자세한건 장고 공홈을 참조 

        ```py
        from django.db import models

        class Table1(models.Model):
            objects  = models.Manager() #vs code 오류 제거용

            no      = models.AutoField(primary_key=True)
            title   = models.CharField(max_length=200)
            content = models.TextField() 
            writer  = models.CharField(max_length=50)
            hit     = models.IntegerField()
            img     = models.BinaryField(null = True)
            regdate = models.DateTimeField(auto_now_add=True)

        ```

# URLconf - URL 정의
- 클라이언트의 요청GET => 가장 먼저요청이 들어있는 URL(urls.py)을 분석 => URL패턴과 매칭되는지를 분석           
- urls.py 파일애 URL과 처리 함수(뷰)를 매핑하는 파이썬코드를 작성 = URLconf          
- URLconf     
    - URLconf를 사용하면 URL과 뷰 함수를 서로 자유롭게 연결할수있음     
        => 규모가 큰 프로젝트르 개발할 때처럼 url과 뷰 함수 이름이 자주 바뀌는 경우에도 URLconf에서 매핑한부분만 수정하면됨 => 변경이 쉬워짐      

### ==== 장고에서 URL을 분석하는 순서 ====
1. setting.py파일의 ROOT_URLCONF항목을 읽어 최상위 URLconf(urls.py)위치를 알아냄    
2. URLconf를 로딩 하여 urlpatterns 변수에 지정되어 있는 URL 리스트를 검사     
3. 위 순서대로 URL 리스트 순서를 검사하면서 URL 패턴에 매치되면 검사를 종료     
4. 매치된 URL의 뷰(함수 또는 메소드)를 호출 => 호출시 httpRequest객체와 매칭할때 추출된 단어들을 뷰에 인자로 넘김        
5. URL 리스트 끝까지 검사했는데 매칭에 실패하면 에러를 처리하는 뷰 호출     
+ URL 패턴 => 정규 표현식 
    - 이를 사용하면 URL을 좀더 세밀하게 표현가능 
    - 복잡한 URL도 표현 가능 

# View - 로직 정의 
- 웹 요청이 있는 URL을 분석 => 해당 URL에 매핑된 뷰를 호출     
    => 해당 app의 로직에 맞는 처리 => 그 결과 데이터를 HTML로 변환      
    => 템플릿처리를 한후 처리된 HTML로된 응답데이터를 웹 클라이언트로 반환하는 역활         
- 다양한 응답데이터를 만들어내기 위한 로직을 뷰에 작성하는것     
    => 함수 또는 글래스의 매서드로 작성 되고 웹 요청을 받고 응답을 반환     
    => 응답은 HTML일수도 있고 리다이렉션 명령 혹은 에러 일수도 있음     
- 뷰는 별도로 작성된 템플릿 파일을 해석해서 HTML코드를 생성      
    => httpRequest객체 담아 클라이언트에 응답       

# Template - 화면 UI 정의
- 장고가 클라이언트에게 반환하는 최종응답은 HTML 텍스트 
- 클라이언트는 응답으로 받은 HTML텍스트를 해석해서 화면에 UI로 보여줌
- 화면에 문제가 생기면 프로그램 로직에 상관없이 문법에 맞게 템플릿만 수정 
- 디자이너와 개발자의 협업이 편리 
- 템플릿 태그/필터기능을 이용해서 파이썬코드를 직접 사용가능     
=> 강력하고 확장하기 쉬운구조    



# 일단 여기까지  

# MVT 코딩순서 
- 정해진 순서는 없음 
    => 자신만의 코딩순서를 정하는게 좋음      
    => 로직을 풀어나가는 데 일관성 유지 + 웹 개발 노하우 빨리 습득           

- 화면설계는 뷰와 템플릿 코딩으로 연결, 테이블 설계 모델 코딩에 반영      
- 독립적으로 개발할 수 있는 모델을 먼저 코딩      
    => 뷰와 템플릿은 서로 영향을 미치므로 모델 이후에 같이 코딩하는것이 *일반적*  

- **UI 화면을 생각하면서 로직을 풀어나가는 것이 쉬움** 그래서 보통은 템플릿을 먼저 코딩  
- 뷰의 코딩이 매우 간단한 경우 뷰를 먼저 코딩 그다음 템플릿을 코딩(클래스형 뷰)     

**일반적인 진행순서**    
- 함수형 뷰     
    - 모델 -> 템플릿 -> 뷰     
- 클래스형 뷰     
    - 모델 -> 뷰 -> 템플릿     
    
### 순서  
Step - 1      
프로젝트 뼈대 만들기      
    - 프로젝트 및 앱 개발에 필요한 디렉토리와 파일 생성       
Step - 2     
모델 코딩하기
    - 테이블 관련 사항을 개발 (models.py, admin.py)     
Step - 3      
URLconf 코딩하기      
    - URL 및 뷰 매핑관계를 정의(urls.py)      
Step - 4      
템플릿 코딩하기      
    - 화면 UI 개발(templates/ 디렉토리 하위의 *.html파일들)     
Step - 5      
뷰 코딩하기      
    - 애플리케이션 로직 개발 (views.py 파일 )      

