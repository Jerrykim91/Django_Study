## chapter01. 웹 프로그래밍의 이해 
---

### 1. 웹 프로그래밍의 정의 

- 웹 프로그래밍이란 ?

	- HTTP와 통신하는 클라이언트와 서버를 개발하는 것

		- 웹 클라이언트 같은 의미

			- Frontend
			- 웹 브라우저 

		- 웹 서버 같은 의미

			- Backend
			- 서버

		- HTTP는 중간다리 => 요청과 응답을 전송

---

### 2. 다양한 웹 클라이언트

- 1. 웹브라우저를 사용하여 요청 

	- 기존 url을 이용하여 접속

		- http://www.example.com
		- http://www.naver.com

- 2. 리눅스 curl명령을 사용하여 요청 

	- HTTP/HTTPs/FTP등 여러가지 프로토콜을 사용

		- ` $curl http://www.naver.com` =>  html로 출력


- 3. Telnet을 사용하여 요청

	- 리눅스의 telnet 프로그램을 이용

		- ` $ telnet http://www.naver.com 80`
            ```bash
            GET/HTTP/ 1.1
            Host : http://www.naver.com 
            ```
		- telnet은 터미널창에 입력하는 그대로 웹서버에 전송 

- 4. 직접 만든 클라이언트로 요청

	- 파이썬으로 직접 웹 제작 

        ```py
        import urllib.request
        get_url =urllib.request.urlopen("http://www.naver.com") 
        print(get_url .read().decode('utf-8))
        ```
---

### 3. HTTP 프로토콜

- HTTP(HyperText Transfer Protocol)

	- 웹 서버와 웹 클라이언트 사이에서 데이터를 주고 받기위해 사용되는 통신방식  
	- TCP/IP 프로토콜 위에서 동작 

		- IP 주소를 가져야한다는것 

- HTTP의 메시지 구조

	- 클라이언트에서 서버로 보내는 요청(request)
	- 서버에서 클라이언트로 보내는 응답(response)

- HTTP 처리 방식 8가지

    - 빈도 top 4 

        - GET
            - READ(매핑) 
            - URL정보를 가지고 오는 메소드

        - POST
            - CREATE(매핑)
            - 리소스 생성 - 글 등록 같은 
            - URL결정권이 서버에 있을 때 사용
            - 조금 더 알고 싶어서 자세한건 공부해서 다시 기술 하겠슴

        - PUT
            - UPDATE(매핑)
            - 리소스를 변경하는데 사용 - 글을 업데이트 할때 

            - 리소스를 생성할때도 가능함  =>
                - URL 결정권이 클라이언트에 있을 때
                - 클라이언트가 결정한 타이틀이 그대로 URL이 되는 경우 

            - 조금더 알고 싶어서 자세한건 공부해서 다시 기술 하겠슴

        - DELETE
            - DELETE(매핑)
            - 리소스를 삭제하는 메소드 
            - DELETE의 요청해 대한 응답은 바디를 반환하지 않음  

    - 그외
        - HEAD
        - OPTIONS
        - TRACE
        - CONNECT

- GET과 POST 메소드 

	- 현실적으로 가장 많이 사용하는 메소드
	-  GET과 POST 사용 시
		- GET
			- URL부분의 ? 뒤에 이름 = 값 을 보냄
			- 많은 양의 데이터를 보내기가 어려움
			- 길이 제한이 존재
			- 전달되는 사용자 데이터가 주소창에 노출 
				- 보안에 취약해짐

		- POST
			- URL에 포함 시켰던 파라미터들을 요청 메세지 바디안에 넣음

- 상태 코드

	- 세자리 숫자로 이루어짐

		- 첫번쨰

			- http 응답의 종류를 구분

		- 두,세번쨰

			- 세부적인 응답 내용의 구분을 위한 번호

	- 상태 코드 분류

		- 1XX

			- 조건부 응답(정보 전달)

				- 요청을 받았고, 작업을 진행 중이라는 의미
				- 임시적인 응답

					- 지금까지의 상태가 괜찮으며 클라이언트가 계속해서 요청을 하거나 이미 요청을 완료한 경우에는 무시해도 되는 것을 알려줌

				- HTTP/1.0 이후 정의되지 않았다. 서버도 클라이언트에 이 코드를 보내지는 않음

		- 2XX

			- 성공

				- 성공적으로 받았고, 이해했으며, 받아들여졌다는 의미
				- 요청이 성공적
				- HTTP 메소드에 따라 달라

					- GET: 리소스를 불러와서 메시지 바디에 전송
					- HEAD: 개체 해더가 메시지 바디에 있음
					- PUT 또는 POST: 수행 결과에 대한 리소스가 메시지 바디에 전송
					- TRACE: 메시지 바디는 서버에서 수신한 요청 메시지를 포함

		- 3XX

			- 리다이렉션 완료

				- 요청을 완료하기 위해서는 리다이렉션이 이루어져야 한다는 의미
				- 추가적인 동작이 필요 

					- 요청한 URL의 문서이동 그주소로 다시 시도하라는 것

		- 4XX

			- 클라이언트(요청) 에러

				- 이 요청은 올바르지 않다는 의미
				-  브라우저에 직접 표출
				- 클라이언트의 요청메시지가 잘못된 경우

		- 5XX

			- 서버 오류

				- 올바른 요청에 대해 서버가 응답할 수 없다는 의미
				- 서버측 에러

					- 서버의 부하
					- DB 처리과정의 오류
					- 서버의 익셉션이 발생하는 경우

	- [자주 사용되는 상태 코드](https://joylife052.tistory.com/entry/%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-HTTP-%EC%83%81%ED%83%9C%EC%BD%94%EB%93%9C-%EC%A0%95%EB%A6%AC)

---

### 4. URL 설계

- URL 설계

	- 사용자에게 웹서버가 가지고 있는 기능을 명시해주는 단계
	- 고객의 요구사항이 정리

		- 1. 디자인측면 정리 => UI를 설계
		- 2. 프로그램 로직 => URL을 설계

	- 전체 로직을 생각

		- 차후에 로직이 변경되더라도 URL변경은 최소화 할수있도록 유연하게 설계해야함

	- URL의 구성 

		- URL 스킴
			- URL의 프로토콜
		- 호스트명
			- 도메인 명 혹은 IP 주소
		- 포트 번호
			- 서비스 포트번호 
				- 생략시 디폴트 
				- HTTP : 80
				- HTTPS:443
		- 경로
			- 파일이나 애플리케이션 경로
		- 쿼리스트링
			- 질의 문자열로 앰퍼샌드(&)로 구분된 이름 = 값 쌍 형식으로 표현
		- 플라그먼트
			- 문서내의 앵커등 조각을 지정 

- URL을 바라보는 측면

	- RPC (Remote procedure call)

		: 클라이언트가 네트워크상에서 원격에 있는 서버가 제공하는 API 함수를 호출하는 방식
		- URL의 경로를 API함수명으로, 쿼리 파라메터의 함수인자로 간주
		 => URL을 전송 = 웹서버 API함수를 호출 => 인식

	-  REST (Representational State Transfer)  

		: 웹서버에 존재하는 요소들을 모두 리소스(시간이 지나면 상태변함 => 조작은 HTTP메소드)라고 정의
		=> URL을 통해 웹서버의 특정리소스를 표현한다는 개념

- 간편 URL

	- 쿼드스트링 없이 경로만 가진 간단한 구조의 URL 
	- 검색 엔진의 처리를 최적화하기 위해 생겨남 
	- 입력하기도 기억하기도 쉬움
	- 검색 엔진 친화적, 사용자 친화적URL

- 파이썬의 우아한 URL

	- 정규표현식을 추가적으로 사용가능함
	- => URL을 좀더 구체적으로 표현 가능

---

### 5. 웹 어플리케이션 서버

- 요청을 받아 처리하는 서버를 통칭 => '웹 서버'
- 세분화

	- 웹서버(정적) 
    : 웹클라이언트의 요청을 받아서 요청을 처리      
        => 그 결과를 클라이언트에게 응답( HTML, IMG, CSS... )

	- 웹 애플리케이션(동적)
     : 웹서버로부터 동적페이지 요청을 받아서 요청을 처리        
     => 그 결과를 웹서버로 반환( 프로그램실행, DB )

- 1. **정적, 동적**

	- 사용자가 페이지를 요청하는 시점에 페이지의 내용이 유지되는가 변경되는가를 구분하는 용어

		- 정적인 페이지란 ?
			- 누가, 언제 요구하더라도 항상 같은 내용을 표시하는 웹페이지
			- 주로 자바스크립트, HTML, CSS 등등...

		- 동적인 페이지란 ?
			- 동일한 리소스의 요청이라도 누가, 언제 어떻게 요구했는지에 따라 각각 다른 내용이 반환되는 페이지를 말함
			- 온라인쇼핑 사이트에서 사용자마다 다른카트 내용을 보여주는 페이지

- 2. CGI 방식의 단점        

    - 독립적이 별도의 프로세스가 생성 

    - 요청이 많아지면 프로세스가 많아 짐

    - 프로세스가 많아 질수록 프로세스가 많아지고 프로세스가 많아질수록 비례적으로 프로세스가 점유하는 메모리 요구량도 커져서 시스템에 많은 부하가 발생 

<img src="https://github.com/Jerrykim91/Django_Study/blob/master/data/CGI%EB%B0%A9%EC%8B%9D%EC%9D%98%20%EC%9A%94%EC%B2%AD%EC%B2%98%EB%A6%AC.PNG?raw=true" width="700" height="200">      

=> CGI방식의 요청처리     

3. CGI 방식의 대안 기술

    - 별도의 애플리케이션을 PERL, PHP등의 스크립트언어로 적성     
    - 그스크립트를 처리하는 스크립트 엔진을 웹서버에 내장  
    - CGI 방식의 단점인 별도의 프로세스를 기동시키는 오버헤드를 줄이는 것 

    - 현재 가장 많이 사용되고 있는 것 
        - JSP
        - ASP

4. 애플리케이션 서버방식

    - 웹사이트를 설계할때       
        - 가장 먼저 해야할일 => 프로그램이 할일을 정당한 크기로 나누어서 모듈화 하는것       
        - 즉, 프로그램으로 코딩할 대상을 애플리케이션이라 명명      
    - 장고에서는 애플리케이션들이 모여서 프로젝트를 개발하는 개념을 가지고 있음 
        - 전체 프로그램 => 프로젝트(project)      
        - 애플리케이션  => 모듈화된 단위프로그램 

---      

<img src="https://github.com/Jerrykim91/Django_Study/blob/master/data/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%84%9C%EB%B2%84%EB%B0%A9%EC%8B%9D%EC%9D%98%20%EC%9A%94%EC%B2%AD%EC%B2%98%EB%A6%AC.PNG?raw=true" width="700" height="200">      

    - APP 서버방식의 요청 처리     
---    
<img src="https://github.com/Jerrykim91/Django_Study/blob/master/data/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%84%9C%EB%B2%84%EB%B0%A9%EC%8B%9D%EC%97%90%EC%84%9C%EC%9D%98%20%EC%84%9C%EB%B2%84%20%EA%B0%84%20%EA%B5%AC%EC%84%B1%EB%8F%84.PNG?raw=true" width="700" height="200">     

    - APP 서버방식에서의 서버간 구성도     
---
- 웹서버와 웹어플리케이션이 분리     
    => 역활도 구분하여 사용      
- 정적인 페이지를 처리하는 경우에 비해서 동적 페이지를 처리하는 경우가 메모리를 정-말 많이 소비       
    => 정적이 페이지처리에 특화된 웹서버는 정적인 페이지에서만 처리        
    => 웹어플리케이션 서버는 동적인 페이지만 처리하도록 역활분담을 하는것이 좋음      
    => 둘다 모두 처리하는것보다 훨-씬 더많은 요청을 처리할 수있음     
---
