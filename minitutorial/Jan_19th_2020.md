# Jan_19th_2020
---

# 노트 

bbs-> board 명명

### 인트로

```py
# 1차 코드 =========================================
# board/views.py 
# 핸들러 선언 => 첫인자는 항상 request
def hello(request):
    # 핸들러 반환 값 => HttpResponse() 통해 문자열을 반환
    return HttpResponse('Hello world!')
    # 핸들러를 호출하기위해서 urls.py에 추가 

# board\urls.py
urlpatterns = [
    # 추가함으로서 'hello/'라는 경로 hello 핸들러가 호출
    path('hello', views.hello , name ='hello'),       
]
#====================================================
```
### 커맨드창 명령어

```bash
# 모델 저장후 생성  
$ python manage.py check
$ python manage.py makemigrations 앱이름
$ python manage.py migrate 앱이름

# 모델 수정시 
(base) C:\minitutorial>python manage.py makemigrations board
Did you rename article.auther to article.author (a CharField)? [y/N] y

```

### 장고 쉘 실습 + 디비에 데이터 추가 

```bash
$ python manage.py shell

----------------------------------------------

# 데이터 저장
>>> from bbs.models import Article
>>> article = Article.objects.create(title='How to create a article', content='1. import Article class\n2. invoke \'create\' method of Article\'s manager.', author='swarf00', created_at='2018-11-22')
>>> print(article)
Article object (1)
>>> print('{} title: {}, content: {}, author: {} created_at: {}'.format(article.id, article.title, article.content, article.author, article.created_at))
title: How to create a article, content: 1. import Article class
2. invoke 'create' method of Article's manager., author: swarf00 created_at: 2018-11-22 01:15:21.135315

----------------------------------------------

# 데이터 수정 
>>> from bbs.models import Article
# sql의 where에 해당하는 내용을 인자로 전달
>>> article = Article.objects.get(id=1)     # id가 1인 Article 데이터 검색. 없거나 2개 이상일 경우 에러발생
>>> print(article)
<Article: [1] How to create a article>
>>> article.created_at = '2020-01-19 02:21'
>>> article.save()                          # 변경된 값 저장. `time formatter('%Y-%m-%d %H:%M')` 형식의 문자열은 DateTimeField에서 자동으로 시간 데이터로 변환해줍니다.
>>> article.created_at.strftime('%Y-%m-%d') # 변경된 created_at 값을 time fomatter를 이용해 출력해보지만 에러발생
----------------------------------------------
AttributeError                            
Traceback (most recent call last)
<ipython-input-16-560946d1936a> in <module>
----> 1 article.created_at.strftime('%Y-%m-%d')
----------------------------------------------
AttributeError: 'str' object has no attribute 'strftime'
>>> article.refresh_from_db()               # db로 부터 새로 검색
>>> article.created_at.strftime('%Y-%m-%d') # 정상출력
'2020-01-19'

```

## 관리자 등록 + admin site에 모델도 등록
---

```bash
$ python manage.py createsuperuser

(base) C:\minitutorial> python manage.py createsuperuser

Username (leave blank to use 'jerrykim'): admin
Email address: sun4131@gmail.com
Password:
Password (again):
This password is too short. It must contain at least 8 characters.
This password is too common.
This password is entirely numeric.
Bypass password validation and create user anyway? [y/N]: y
Superuser created successfully.

http://127.0.0.1:8000/admin 접속

```


## 화면 구성 
---
- 목록, 상세, 수정, 추가
    - 수정, 추가 => 추가화면에는 각 입력값이 빈 상태 
    - 수정화면은 추가화면에 데이터베이스에 저장된 값으로 초기화


### 화면 핸들러 정의하기

``` py 
# 틀 깔기 => 더미 핸들러로 테스트( request.methode == 'GET')
from django.http import HttpResponse
  
def hello(request, to):
    return HttpResponse('Hello {}.'.format(to))

def list_article(request):                          
    return HttpResponse('list')

def detail_article(request, article_id):            
    return HttpResponse('detail {}'.format(article_id))

def create_or_update_article(request, article_id):   
    if article_id:
        return HttpResponse('update {}'.format(article_id))
    else:
        return HttpResponse('create')


# 하위 urls.py에 연결  => board\urls.py
urlpatterns = [

    path('hello/<to>', views.hello , name ='hello'),     

    # 게시판 기능 경로 추가  
    path('article/', views.list_article , name ='list_article'),       
    path('article/<article_id>/', views.detail_article, name ='detail_article'), 
    # create => name정의 하니까 에러 나중에 재도전
    path('article/create/', views.create_or_update_article,{'article_id':None}),        
    # {'article_id':None} 필수
    # update => name정의 하니까 에러 나중에 재도전
    path('article/<article_id>/update/', views.create_or_update_article),       

]

# 핸들러에 article_id()함수의 기본값이 없기 때문에 추가 파라미터를 {'article_id':None} 필수 입력 

#--------------------------------------------------------
# 동작하는지 실행해보기 

# http://127.0.0.1:8000/board/article/           # 'list' 출력
# http://127.0.0.1:8000/board/article/create/    # 'detail create' 출력
# http://127.0.0.1:8000/board/article/8/         # 'detail 8'  출력
# http://127.0.0.1:8000/board/article/12/update/ # 'update 12' 출력

```

## 액션 핸들러 정의하기 
---

- 더미 핸들러로 테스트후 화면 내에서 사용자 입력을 처리하는 핸들러를 구현 
- 더미와 액션을 별도로 구분 

```py
from django.http import HttpResponse, HttpResponseNotAllowed


def do_create_article(request): # 생성 액션
    return HttpResponse(request.POST)

def do_update_article(request): # 수정 액션
    return HttpResponse(request.POST)

# 구조를 보기위해 간격을 둠 
def create_or_update_article(request, article_id):

# article_id의 여부에 따라 if문으로 분리 
    if article_id: # 수정하기
        # 
        if request.method == 'GET':
            return HttpResponse('update {}'.format(article_id))
        elif request.method == 'POST':
            return do_create_article(request)
        else:
            return HttpResponseNotAllowed(['GET', 'POST'])

    else:  # 생성하기
        # 
        if request.method == 'GET':
            return HttpResponse('create')
        elif request.method == 'POST':
            return do_update_article(request)
        else:
            return HttpResponseNotAllowed(['GET', 'POST'])

# HttpResponseNotAllowed() => 허용되지 않는 메소드로 요청했다는 의미
```

> **DRY 원칙 !**     
   > DRY (Don't Repeat Yourself) Principle   
    >- 똑같은 일을 두번 하지 않을 것
    >- 중복되는 함수나 코드는 하나의 공통의 콤포넌트(함수)에 넣고 사용할 것
    >- 큰 시스템을 여러 조각으로 나누고 서로 참조할 것


#### 장고에서는 FBV(Function Based View)와 CBV(Class Based View) 두가지의 뷰를 개발할 수 있는 방법을 제공

```py
# Class Based View로 변경
from django.http import HttpResponse
from django.views.generic import TemplateView


class ArticleListView(TemplateView):         # 게시글 목록
    template_name = 'base.html'

    def get(self, request, *args, **kwargs):
        ctx = {}                             # 템플릿에 전달할 데이터
        return self.render_to_response(ctx)


class ArticleDetailView(TemplateView):       # 게시글 상세
    template_name = 'base.html'

    def get(self, request, *args, **kwargs):
        ctx = {}
        return self.render_to_response(ctx)


class ArticleCreateUpdateView(TemplateView):  # 게시글 추가, 수정
    template_name = 'base.html'

    def get(self, request, *args, **kwargs):  # 화면 요청
        ctx = {}
        return self.render_to_response(ctx)

    def post(self, request, *args, **kwargs): # 액션
        ctx = {}
        return self.render_to_response(ctx)


def hello(request, to):
    return HttpResponse('Hello {}.'.format(to))


# 핸들러가 함수에서 클래스로 변경 -> url 연결도 변경
# board/urls.py

from django.contrib import admin
from django.urls import path

from bbs.views import hello, ArticleListView, ArticleDetailView, ArticleCreateUpdateView

urlpatterns = [
    path('hello/<to>', hello), 

    path('article/', ArticleListView.as_view()),
    path('article/create/', ArticleCreateUpdateView.as_view()),
    path('article/<article_id>/', ArticleDetailView.as_view()),
    path('article/<article_id>/update/', ArticleCreateUpdateView.as_view()),

    path('admin/', admin.site.urls),
]
```